{"ast":null,"code":"const _require = require('./defaults.js'),\n      defaults = _require.defaults;\n\nconst _require2 = require('./rules.js'),\n      block = _require2.block;\n\nconst _require3 = require('./helpers.js'),\n      rtrim = _require3.rtrim,\n      splitCells = _require3.splitCells,\n      escape = _require3.escape;\n/**\n * Block Lexer\n */\n\n\nmodule.exports = class Lexer {\n  constructor(options) {\n    this.tokens = [];\n    this.tokens.links = Object.create(null);\n    this.options = options || defaults;\n    this.rules = block.normal;\n\n    if (this.options.pedantic) {\n      this.rules = block.pedantic;\n    } else if (this.options.gfm) {\n      this.rules = block.gfm;\n    }\n  }\n  /**\n   * Expose Block Rules\n   */\n\n\n  static get rules() {\n    return block;\n  }\n  /**\n   * Static Lex Method\n   */\n\n\n  static lex(src, options) {\n    const lexer = new Lexer(options);\n    return lexer.lex(src);\n  }\n\n  /**\n   * Preprocessing\n   */\n  lex(src) {\n    src = src.replace(/\\r\\n|\\r/g, '\\n').replace(/\\t/g, '    ');\n    return this.token(src, true);\n  }\n\n  /**\n   * Lexing\n   */\n  token(src, top) {\n    src = src.replace(/^ +$/gm, '');\n    let next, loose, cap, bull, b, item, listStart, listItems, t, space, i, tag, l, isordered, istask, ischecked;\n\n    while (src) {\n      // newline\n      if (cap = this.rules.newline.exec(src)) {\n        src = src.substring(cap[0].length);\n\n        if (cap[0].length > 1) {\n          this.tokens.push({\n            type: 'space'\n          });\n        }\n      } // code\n\n\n      if (cap = this.rules.code.exec(src)) {\n        const lastToken = this.tokens[this.tokens.length - 1];\n        src = src.substring(cap[0].length); // An indented code block cannot interrupt a paragraph.\n\n        if (lastToken && lastToken.type === 'paragraph') {\n          lastToken.text += '\\n' + cap[0].trimRight();\n        } else {\n          cap = cap[0].replace(/^ {4}/gm, '');\n          this.tokens.push({\n            type: 'code',\n            codeBlockStyle: 'indented',\n            text: !this.options.pedantic ? rtrim(cap, '\\n') : cap\n          });\n        }\n\n        continue;\n      } // fences\n\n\n      if (cap = this.rules.fences.exec(src)) {\n        src = src.substring(cap[0].length);\n        this.tokens.push({\n          type: 'code',\n          lang: cap[2] ? cap[2].trim() : cap[2],\n          text: cap[3] || ''\n        });\n        continue;\n      } // heading\n\n\n      if (cap = this.rules.heading.exec(src)) {\n        src = src.substring(cap[0].length);\n        this.tokens.push({\n          type: 'heading',\n          depth: cap[1].length,\n          text: cap[2]\n        });\n        continue;\n      } // table no leading pipe (gfm)\n\n\n      if (cap = this.rules.nptable.exec(src)) {\n        item = {\n          type: 'table',\n          header: splitCells(cap[1].replace(/^ *| *\\| *$/g, '')),\n          align: cap[2].replace(/^ *|\\| *$/g, '').split(/ *\\| */),\n          cells: cap[3] ? cap[3].replace(/\\n$/, '').split('\\n') : []\n        };\n\n        if (item.header.length === item.align.length) {\n          src = src.substring(cap[0].length);\n\n          for (i = 0; i < item.align.length; i++) {\n            if (/^ *-+: *$/.test(item.align[i])) {\n              item.align[i] = 'right';\n            } else if (/^ *:-+: *$/.test(item.align[i])) {\n              item.align[i] = 'center';\n            } else if (/^ *:-+ *$/.test(item.align[i])) {\n              item.align[i] = 'left';\n            } else {\n              item.align[i] = null;\n            }\n          }\n\n          for (i = 0; i < item.cells.length; i++) {\n            item.cells[i] = splitCells(item.cells[i], item.header.length);\n          }\n\n          this.tokens.push(item);\n          continue;\n        }\n      } // hr\n\n\n      if (cap = this.rules.hr.exec(src)) {\n        src = src.substring(cap[0].length);\n        this.tokens.push({\n          type: 'hr'\n        });\n        continue;\n      } // blockquote\n\n\n      if (cap = this.rules.blockquote.exec(src)) {\n        src = src.substring(cap[0].length);\n        this.tokens.push({\n          type: 'blockquote_start'\n        });\n        cap = cap[0].replace(/^ *> ?/gm, ''); // Pass `top` to keep the current\n        // \"toplevel\" state. This is exactly\n        // how markdown.pl works.\n\n        this.token(cap, top);\n        this.tokens.push({\n          type: 'blockquote_end'\n        });\n        continue;\n      } // list\n\n\n      if (cap = this.rules.list.exec(src)) {\n        src = src.substring(cap[0].length);\n        bull = cap[2];\n        isordered = bull.length > 1;\n        listStart = {\n          type: 'list_start',\n          ordered: isordered,\n          start: isordered ? +bull : '',\n          loose: false\n        };\n        this.tokens.push(listStart); // Get each top-level item.\n\n        cap = cap[0].match(this.rules.item);\n        listItems = [];\n        next = false;\n        l = cap.length;\n        i = 0;\n\n        for (; i < l; i++) {\n          item = cap[i]; // Remove the list item's bullet\n          // so it is seen as the next token.\n\n          space = item.length;\n          item = item.replace(/^ *([*+-]|\\d+\\.) */, ''); // Outdent whatever the\n          // list item contains. Hacky.\n\n          if (~item.indexOf('\\n ')) {\n            space -= item.length;\n            item = !this.options.pedantic ? item.replace(new RegExp('^ {1,' + space + '}', 'gm'), '') : item.replace(/^ {1,4}/gm, '');\n          } // Determine whether the next list item belongs here.\n          // Backpedal if it does not belong in this list.\n\n\n          if (i !== l - 1) {\n            b = block.bullet.exec(cap[i + 1])[0];\n\n            if (bull.length > 1 ? b.length === 1 : b.length > 1 || this.options.smartLists && b !== bull) {\n              src = cap.slice(i + 1).join('\\n') + src;\n              i = l - 1;\n            }\n          } // Determine whether item is loose or not.\n          // Use: /(^|\\n)(?! )[^\\n]+\\n\\n(?!\\s*$)/\n          // for discount behavior.\n\n\n          loose = next || /\\n\\n(?!\\s*$)/.test(item);\n\n          if (i !== l - 1) {\n            next = item.charAt(item.length - 1) === '\\n';\n            if (!loose) loose = next;\n          }\n\n          if (loose) {\n            listStart.loose = true;\n          } // Check for task list items\n\n\n          istask = /^\\[[ xX]\\] /.test(item);\n          ischecked = undefined;\n\n          if (istask) {\n            ischecked = item[1] !== ' ';\n            item = item.replace(/^\\[[ xX]\\] +/, '');\n          }\n\n          t = {\n            type: 'list_item_start',\n            task: istask,\n            checked: ischecked,\n            loose: loose\n          };\n          listItems.push(t);\n          this.tokens.push(t); // Recurse.\n\n          this.token(item, false);\n          this.tokens.push({\n            type: 'list_item_end'\n          });\n        }\n\n        if (listStart.loose) {\n          l = listItems.length;\n          i = 0;\n\n          for (; i < l; i++) {\n            listItems[i].loose = true;\n          }\n        }\n\n        this.tokens.push({\n          type: 'list_end'\n        });\n        continue;\n      } // html\n\n\n      if (cap = this.rules.html.exec(src)) {\n        src = src.substring(cap[0].length);\n        this.tokens.push({\n          type: this.options.sanitize ? 'paragraph' : 'html',\n          pre: !this.options.sanitizer && (cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style'),\n          text: this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0]) : cap[0]\n        });\n        continue;\n      } // def\n\n\n      if (top && (cap = this.rules.def.exec(src))) {\n        src = src.substring(cap[0].length);\n        if (cap[3]) cap[3] = cap[3].substring(1, cap[3].length - 1);\n        tag = cap[1].toLowerCase().replace(/\\s+/g, ' ');\n\n        if (!this.tokens.links[tag]) {\n          this.tokens.links[tag] = {\n            href: cap[2],\n            title: cap[3]\n          };\n        }\n\n        continue;\n      } // table (gfm)\n\n\n      if (cap = this.rules.table.exec(src)) {\n        item = {\n          type: 'table',\n          header: splitCells(cap[1].replace(/^ *| *\\| *$/g, '')),\n          align: cap[2].replace(/^ *|\\| *$/g, '').split(/ *\\| */),\n          cells: cap[3] ? cap[3].replace(/\\n$/, '').split('\\n') : []\n        };\n\n        if (item.header.length === item.align.length) {\n          src = src.substring(cap[0].length);\n\n          for (i = 0; i < item.align.length; i++) {\n            if (/^ *-+: *$/.test(item.align[i])) {\n              item.align[i] = 'right';\n            } else if (/^ *:-+: *$/.test(item.align[i])) {\n              item.align[i] = 'center';\n            } else if (/^ *:-+ *$/.test(item.align[i])) {\n              item.align[i] = 'left';\n            } else {\n              item.align[i] = null;\n            }\n          }\n\n          for (i = 0; i < item.cells.length; i++) {\n            item.cells[i] = splitCells(item.cells[i].replace(/^ *\\| *| *\\| *$/g, ''), item.header.length);\n          }\n\n          this.tokens.push(item);\n          continue;\n        }\n      } // lheading\n\n\n      if (cap = this.rules.lheading.exec(src)) {\n        src = src.substring(cap[0].length);\n        this.tokens.push({\n          type: 'heading',\n          depth: cap[2].charAt(0) === '=' ? 1 : 2,\n          text: cap[1]\n        });\n        continue;\n      } // top-level paragraph\n\n\n      if (top && (cap = this.rules.paragraph.exec(src))) {\n        src = src.substring(cap[0].length);\n        this.tokens.push({\n          type: 'paragraph',\n          text: cap[1].charAt(cap[1].length - 1) === '\\n' ? cap[1].slice(0, -1) : cap[1]\n        });\n        continue;\n      } // text\n\n\n      if (cap = this.rules.text.exec(src)) {\n        // Top-level should never reach here.\n        src = src.substring(cap[0].length);\n        this.tokens.push({\n          type: 'text',\n          text: cap[0]\n        });\n        continue;\n      }\n\n      if (src) {\n        throw new Error('Infinite loop on byte: ' + src.charCodeAt(0));\n      }\n    }\n\n    return this.tokens;\n  }\n\n};","map":{"version":3,"sources":["/Users/aziz/Documents/Aziz-Final-project-react-new-markdown-previewer-hooks/node_modules/marked/src/Lexer.js"],"names":["require","defaults","block","rtrim","splitCells","escape","module","exports","Lexer","constructor","options","tokens","links","Object","create","rules","normal","pedantic","gfm","lex","src","lexer","replace","token","top","next","loose","cap","bull","b","item","listStart","listItems","t","space","i","tag","l","isordered","istask","ischecked","newline","exec","substring","length","push","type","code","lastToken","text","trimRight","codeBlockStyle","fences","lang","trim","heading","depth","nptable","header","align","split","cells","test","hr","blockquote","list","ordered","start","match","indexOf","RegExp","bullet","smartLists","slice","join","charAt","undefined","task","checked","html","sanitize","pre","sanitizer","def","toLowerCase","href","title","table","lheading","paragraph","Error","charCodeAt"],"mappings":"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","sourcesContent":["const { defaults } = require('./defaults.js');\nconst { block } = require('./rules.js');\nconst {\n  rtrim,\n  splitCells,\n  escape\n} = require('./helpers.js');\n\n/**\n * Block Lexer\n */\nmodule.exports = class Lexer {\n  constructor(options) {\n    this.tokens = [];\n    this.tokens.links = Object.create(null);\n    this.options = options || defaults;\n    this.rules = block.normal;\n\n    if (this.options.pedantic) {\n      this.rules = block.pedantic;\n    } else if (this.options.gfm) {\n      this.rules = block.gfm;\n    }\n  }\n\n  /**\n   * Expose Block Rules\n   */\n  static get rules() {\n    return block;\n  }\n\n  /**\n   * Static Lex Method\n   */\n  static lex(src, options) {\n    const lexer = new Lexer(options);\n    return lexer.lex(src);\n  };\n\n  /**\n   * Preprocessing\n   */\n  lex(src) {\n    src = src\n      .replace(/\\r\\n|\\r/g, '\\n')\n      .replace(/\\t/g, '    ');\n\n    return this.token(src, true);\n  };\n\n  /**\n   * Lexing\n   */\n  token(src, top) {\n    src = src.replace(/^ +$/gm, '');\n    let next,\n      loose,\n      cap,\n      bull,\n      b,\n      item,\n      listStart,\n      listItems,\n      t,\n      space,\n      i,\n      tag,\n      l,\n      isordered,\n      istask,\n      ischecked;\n\n    while (src) {\n      // newline\n      if (cap = this.rules.newline.exec(src)) {\n        src = src.substring(cap[0].length);\n        if (cap[0].length > 1) {\n          this.tokens.push({\n            type: 'space'\n          });\n        }\n      }\n\n      // code\n      if (cap = this.rules.code.exec(src)) {\n        const lastToken = this.tokens[this.tokens.length - 1];\n        src = src.substring(cap[0].length);\n        // An indented code block cannot interrupt a paragraph.\n        if (lastToken && lastToken.type === 'paragraph') {\n          lastToken.text += '\\n' + cap[0].trimRight();\n        } else {\n          cap = cap[0].replace(/^ {4}/gm, '');\n          this.tokens.push({\n            type: 'code',\n            codeBlockStyle: 'indented',\n            text: !this.options.pedantic\n              ? rtrim(cap, '\\n')\n              : cap\n          });\n        }\n        continue;\n      }\n\n      // fences\n      if (cap = this.rules.fences.exec(src)) {\n        src = src.substring(cap[0].length);\n        this.tokens.push({\n          type: 'code',\n          lang: cap[2] ? cap[2].trim() : cap[2],\n          text: cap[3] || ''\n        });\n        continue;\n      }\n\n      // heading\n      if (cap = this.rules.heading.exec(src)) {\n        src = src.substring(cap[0].length);\n        this.tokens.push({\n          type: 'heading',\n          depth: cap[1].length,\n          text: cap[2]\n        });\n        continue;\n      }\n\n      // table no leading pipe (gfm)\n      if (cap = this.rules.nptable.exec(src)) {\n        item = {\n          type: 'table',\n          header: splitCells(cap[1].replace(/^ *| *\\| *$/g, '')),\n          align: cap[2].replace(/^ *|\\| *$/g, '').split(/ *\\| */),\n          cells: cap[3] ? cap[3].replace(/\\n$/, '').split('\\n') : []\n        };\n\n        if (item.header.length === item.align.length) {\n          src = src.substring(cap[0].length);\n\n          for (i = 0; i < item.align.length; i++) {\n            if (/^ *-+: *$/.test(item.align[i])) {\n              item.align[i] = 'right';\n            } else if (/^ *:-+: *$/.test(item.align[i])) {\n              item.align[i] = 'center';\n            } else if (/^ *:-+ *$/.test(item.align[i])) {\n              item.align[i] = 'left';\n            } else {\n              item.align[i] = null;\n            }\n          }\n\n          for (i = 0; i < item.cells.length; i++) {\n            item.cells[i] = splitCells(item.cells[i], item.header.length);\n          }\n\n          this.tokens.push(item);\n\n          continue;\n        }\n      }\n\n      // hr\n      if (cap = this.rules.hr.exec(src)) {\n        src = src.substring(cap[0].length);\n        this.tokens.push({\n          type: 'hr'\n        });\n        continue;\n      }\n\n      // blockquote\n      if (cap = this.rules.blockquote.exec(src)) {\n        src = src.substring(cap[0].length);\n\n        this.tokens.push({\n          type: 'blockquote_start'\n        });\n\n        cap = cap[0].replace(/^ *> ?/gm, '');\n\n        // Pass `top` to keep the current\n        // \"toplevel\" state. This is exactly\n        // how markdown.pl works.\n        this.token(cap, top);\n\n        this.tokens.push({\n          type: 'blockquote_end'\n        });\n\n        continue;\n      }\n\n      // list\n      if (cap = this.rules.list.exec(src)) {\n        src = src.substring(cap[0].length);\n        bull = cap[2];\n        isordered = bull.length > 1;\n\n        listStart = {\n          type: 'list_start',\n          ordered: isordered,\n          start: isordered ? +bull : '',\n          loose: false\n        };\n\n        this.tokens.push(listStart);\n\n        // Get each top-level item.\n        cap = cap[0].match(this.rules.item);\n\n        listItems = [];\n        next = false;\n        l = cap.length;\n        i = 0;\n\n        for (; i < l; i++) {\n          item = cap[i];\n\n          // Remove the list item's bullet\n          // so it is seen as the next token.\n          space = item.length;\n          item = item.replace(/^ *([*+-]|\\d+\\.) */, '');\n\n          // Outdent whatever the\n          // list item contains. Hacky.\n          if (~item.indexOf('\\n ')) {\n            space -= item.length;\n            item = !this.options.pedantic\n              ? item.replace(new RegExp('^ {1,' + space + '}', 'gm'), '')\n              : item.replace(/^ {1,4}/gm, '');\n          }\n\n          // Determine whether the next list item belongs here.\n          // Backpedal if it does not belong in this list.\n          if (i !== l - 1) {\n            b = block.bullet.exec(cap[i + 1])[0];\n            if (bull.length > 1 ? b.length === 1\n              : (b.length > 1 || (this.options.smartLists && b !== bull))) {\n              src = cap.slice(i + 1).join('\\n') + src;\n              i = l - 1;\n            }\n          }\n\n          // Determine whether item is loose or not.\n          // Use: /(^|\\n)(?! )[^\\n]+\\n\\n(?!\\s*$)/\n          // for discount behavior.\n          loose = next || /\\n\\n(?!\\s*$)/.test(item);\n          if (i !== l - 1) {\n            next = item.charAt(item.length - 1) === '\\n';\n            if (!loose) loose = next;\n          }\n\n          if (loose) {\n            listStart.loose = true;\n          }\n\n          // Check for task list items\n          istask = /^\\[[ xX]\\] /.test(item);\n          ischecked = undefined;\n          if (istask) {\n            ischecked = item[1] !== ' ';\n            item = item.replace(/^\\[[ xX]\\] +/, '');\n          }\n\n          t = {\n            type: 'list_item_start',\n            task: istask,\n            checked: ischecked,\n            loose: loose\n          };\n\n          listItems.push(t);\n          this.tokens.push(t);\n\n          // Recurse.\n          this.token(item, false);\n\n          this.tokens.push({\n            type: 'list_item_end'\n          });\n        }\n\n        if (listStart.loose) {\n          l = listItems.length;\n          i = 0;\n          for (; i < l; i++) {\n            listItems[i].loose = true;\n          }\n        }\n\n        this.tokens.push({\n          type: 'list_end'\n        });\n\n        continue;\n      }\n\n      // html\n      if (cap = this.rules.html.exec(src)) {\n        src = src.substring(cap[0].length);\n        this.tokens.push({\n          type: this.options.sanitize\n            ? 'paragraph'\n            : 'html',\n          pre: !this.options.sanitizer\n            && (cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style'),\n          text: this.options.sanitize ? (this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0])) : cap[0]\n        });\n        continue;\n      }\n\n      // def\n      if (top && (cap = this.rules.def.exec(src))) {\n        src = src.substring(cap[0].length);\n        if (cap[3]) cap[3] = cap[3].substring(1, cap[3].length - 1);\n        tag = cap[1].toLowerCase().replace(/\\s+/g, ' ');\n        if (!this.tokens.links[tag]) {\n          this.tokens.links[tag] = {\n            href: cap[2],\n            title: cap[3]\n          };\n        }\n        continue;\n      }\n\n      // table (gfm)\n      if (cap = this.rules.table.exec(src)) {\n        item = {\n          type: 'table',\n          header: splitCells(cap[1].replace(/^ *| *\\| *$/g, '')),\n          align: cap[2].replace(/^ *|\\| *$/g, '').split(/ *\\| */),\n          cells: cap[3] ? cap[3].replace(/\\n$/, '').split('\\n') : []\n        };\n\n        if (item.header.length === item.align.length) {\n          src = src.substring(cap[0].length);\n\n          for (i = 0; i < item.align.length; i++) {\n            if (/^ *-+: *$/.test(item.align[i])) {\n              item.align[i] = 'right';\n            } else if (/^ *:-+: *$/.test(item.align[i])) {\n              item.align[i] = 'center';\n            } else if (/^ *:-+ *$/.test(item.align[i])) {\n              item.align[i] = 'left';\n            } else {\n              item.align[i] = null;\n            }\n          }\n\n          for (i = 0; i < item.cells.length; i++) {\n            item.cells[i] = splitCells(\n              item.cells[i].replace(/^ *\\| *| *\\| *$/g, ''),\n              item.header.length);\n          }\n\n          this.tokens.push(item);\n\n          continue;\n        }\n      }\n\n      // lheading\n      if (cap = this.rules.lheading.exec(src)) {\n        src = src.substring(cap[0].length);\n        this.tokens.push({\n          type: 'heading',\n          depth: cap[2].charAt(0) === '=' ? 1 : 2,\n          text: cap[1]\n        });\n        continue;\n      }\n\n      // top-level paragraph\n      if (top && (cap = this.rules.paragraph.exec(src))) {\n        src = src.substring(cap[0].length);\n        this.tokens.push({\n          type: 'paragraph',\n          text: cap[1].charAt(cap[1].length - 1) === '\\n'\n            ? cap[1].slice(0, -1)\n            : cap[1]\n        });\n        continue;\n      }\n\n      // text\n      if (cap = this.rules.text.exec(src)) {\n        // Top-level should never reach here.\n        src = src.substring(cap[0].length);\n        this.tokens.push({\n          type: 'text',\n          text: cap[0]\n        });\n        continue;\n      }\n\n      if (src) {\n        throw new Error('Infinite loop on byte: ' + src.charCodeAt(0));\n      }\n    }\n\n    return this.tokens;\n  };\n};\n"]},"metadata":{},"sourceType":"script"}