{"ast":null,"code":"const Lexer = require('./Lexer.js');\n\nconst Parser = require('./Parser.js');\n\nconst Renderer = require('./Renderer.js');\n\nconst TextRenderer = require('./TextRenderer.js');\n\nconst InlineLexer = require('./InlineLexer.js');\n\nconst Slugger = require('./Slugger.js');\n\nconst _require = require('./helpers.js'),\n      merge = _require.merge,\n      checkSanitizeDeprecation = _require.checkSanitizeDeprecation,\n      escape = _require.escape;\n\nconst _require2 = require('./defaults.js'),\n      getDefaults = _require2.getDefaults,\n      changeDefaults = _require2.changeDefaults,\n      defaults = _require2.defaults;\n/**\n * Marked\n */\n\n\nfunction marked(src, opt, callback) {\n  // throw error in case of non string input\n  if (typeof src === 'undefined' || src === null) {\n    throw new Error('marked(): input parameter is undefined or null');\n  }\n\n  if (typeof src !== 'string') {\n    throw new Error('marked(): input parameter is of type ' + Object.prototype.toString.call(src) + ', string expected');\n  }\n\n  if (callback || typeof opt === 'function') {\n    if (!callback) {\n      callback = opt;\n      opt = null;\n    }\n\n    opt = merge({}, marked.defaults, opt || {});\n    checkSanitizeDeprecation(opt);\n    const highlight = opt.highlight;\n    let tokens,\n        pending,\n        i = 0;\n\n    try {\n      tokens = Lexer.lex(src, opt);\n    } catch (e) {\n      return callback(e);\n    }\n\n    pending = tokens.length;\n\n    const done = function (err) {\n      if (err) {\n        opt.highlight = highlight;\n        return callback(err);\n      }\n\n      let out;\n\n      try {\n        out = Parser.parse(tokens, opt);\n      } catch (e) {\n        err = e;\n      }\n\n      opt.highlight = highlight;\n      return err ? callback(err) : callback(null, out);\n    };\n\n    if (!highlight || highlight.length < 3) {\n      return done();\n    }\n\n    delete opt.highlight;\n    if (!pending) return done();\n\n    for (; i < tokens.length; i++) {\n      (function (token) {\n        if (token.type !== 'code') {\n          return --pending || done();\n        }\n\n        return highlight(token.text, token.lang, function (err, code) {\n          if (err) return done(err);\n\n          if (code == null || code === token.text) {\n            return --pending || done();\n          }\n\n          token.text = code;\n          token.escaped = true;\n          --pending || done();\n        });\n      })(tokens[i]);\n    }\n\n    return;\n  }\n\n  try {\n    opt = merge({}, marked.defaults, opt || {});\n    checkSanitizeDeprecation(opt);\n    return Parser.parse(Lexer.lex(src, opt), opt);\n  } catch (e) {\n    e.message += '\\nPlease report this to https://github.com/markedjs/marked.';\n\n    if ((opt || marked.defaults).silent) {\n      return '<p>An error occurred:</p><pre>' + escape(e.message + '', true) + '</pre>';\n    }\n\n    throw e;\n  }\n}\n/**\n * Options\n */\n\n\nmarked.options = marked.setOptions = function (opt) {\n  merge(marked.defaults, opt);\n  changeDefaults(marked.defaults);\n  return marked;\n};\n\nmarked.getDefaults = getDefaults;\nmarked.defaults = defaults;\n/**\n * Expose\n */\n\nmarked.Parser = Parser;\nmarked.parser = Parser.parse;\nmarked.Renderer = Renderer;\nmarked.TextRenderer = TextRenderer;\nmarked.Lexer = Lexer;\nmarked.lexer = Lexer.lex;\nmarked.InlineLexer = InlineLexer;\nmarked.inlineLexer = InlineLexer.output;\nmarked.Slugger = Slugger;\nmarked.parse = marked;\nmodule.exports = marked;","map":{"version":3,"sources":["/Users/aziz/Documents/Aziz-Final-project-react-new-markdown-previewer-hooks/node_modules/marked/src/marked.js"],"names":["Lexer","require","Parser","Renderer","TextRenderer","InlineLexer","Slugger","merge","checkSanitizeDeprecation","escape","getDefaults","changeDefaults","defaults","marked","src","opt","callback","Error","Object","prototype","toString","call","highlight","tokens","pending","i","lex","e","length","done","err","out","parse","token","type","text","lang","code","escaped","message","silent","options","setOptions","parser","lexer","inlineLexer","output","module","exports"],"mappings":"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","sourcesContent":["const Lexer = require('./Lexer.js');\nconst Parser = require('./Parser.js');\nconst Renderer = require('./Renderer.js');\nconst TextRenderer = require('./TextRenderer.js');\nconst InlineLexer = require('./InlineLexer.js');\nconst Slugger = require('./Slugger.js');\nconst {\n  merge,\n  checkSanitizeDeprecation,\n  escape\n} = require('./helpers.js');\nconst {\n  getDefaults,\n  changeDefaults,\n  defaults\n} = require('./defaults.js');\n\n/**\n * Marked\n */\nfunction marked(src, opt, callback) {\n  // throw error in case of non string input\n  if (typeof src === 'undefined' || src === null) {\n    throw new Error('marked(): input parameter is undefined or null');\n  }\n  if (typeof src !== 'string') {\n    throw new Error('marked(): input parameter is of type '\n      + Object.prototype.toString.call(src) + ', string expected');\n  }\n\n  if (callback || typeof opt === 'function') {\n    if (!callback) {\n      callback = opt;\n      opt = null;\n    }\n\n    opt = merge({}, marked.defaults, opt || {});\n    checkSanitizeDeprecation(opt);\n    const highlight = opt.highlight;\n    let tokens,\n      pending,\n      i = 0;\n\n    try {\n      tokens = Lexer.lex(src, opt);\n    } catch (e) {\n      return callback(e);\n    }\n\n    pending = tokens.length;\n\n    const done = function(err) {\n      if (err) {\n        opt.highlight = highlight;\n        return callback(err);\n      }\n\n      let out;\n\n      try {\n        out = Parser.parse(tokens, opt);\n      } catch (e) {\n        err = e;\n      }\n\n      opt.highlight = highlight;\n\n      return err\n        ? callback(err)\n        : callback(null, out);\n    };\n\n    if (!highlight || highlight.length < 3) {\n      return done();\n    }\n\n    delete opt.highlight;\n\n    if (!pending) return done();\n\n    for (; i < tokens.length; i++) {\n      (function(token) {\n        if (token.type !== 'code') {\n          return --pending || done();\n        }\n        return highlight(token.text, token.lang, function(err, code) {\n          if (err) return done(err);\n          if (code == null || code === token.text) {\n            return --pending || done();\n          }\n          token.text = code;\n          token.escaped = true;\n          --pending || done();\n        });\n      })(tokens[i]);\n    }\n\n    return;\n  }\n  try {\n    opt = merge({}, marked.defaults, opt || {});\n    checkSanitizeDeprecation(opt);\n    return Parser.parse(Lexer.lex(src, opt), opt);\n  } catch (e) {\n    e.message += '\\nPlease report this to https://github.com/markedjs/marked.';\n    if ((opt || marked.defaults).silent) {\n      return '<p>An error occurred:</p><pre>'\n        + escape(e.message + '', true)\n        + '</pre>';\n    }\n    throw e;\n  }\n}\n\n/**\n * Options\n */\n\nmarked.options =\nmarked.setOptions = function(opt) {\n  merge(marked.defaults, opt);\n  changeDefaults(marked.defaults);\n  return marked;\n};\n\nmarked.getDefaults = getDefaults;\n\nmarked.defaults = defaults;\n\n/**\n * Expose\n */\n\nmarked.Parser = Parser;\nmarked.parser = Parser.parse;\n\nmarked.Renderer = Renderer;\nmarked.TextRenderer = TextRenderer;\n\nmarked.Lexer = Lexer;\nmarked.lexer = Lexer.lex;\n\nmarked.InlineLexer = InlineLexer;\nmarked.inlineLexer = InlineLexer.output;\n\nmarked.Slugger = Slugger;\n\nmarked.parse = marked;\n\nmodule.exports = marked;\n"]},"metadata":{},"sourceType":"script"}