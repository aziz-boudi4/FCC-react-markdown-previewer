{"ast":null,"code":"const Renderer = require('./Renderer.js');\n\nconst Slugger = require('./Slugger.js');\n\nconst InlineLexer = require('./InlineLexer.js');\n\nconst TextRenderer = require('./TextRenderer.js');\n\nconst _require = require('./defaults.js'),\n      defaults = _require.defaults;\n\nconst _require2 = require('./helpers.js'),\n      merge = _require2.merge,\n      unescape = _require2.unescape;\n/**\n * Parsing & Compiling\n */\n\n\nmodule.exports = class Parser {\n  constructor(options) {\n    this.tokens = [];\n    this.token = null;\n    this.options = options || defaults;\n    this.options.renderer = this.options.renderer || new Renderer();\n    this.renderer = this.options.renderer;\n    this.renderer.options = this.options;\n    this.slugger = new Slugger();\n  }\n  /**\n   * Static Parse Method\n   */\n\n\n  static parse(tokens, options) {\n    const parser = new Parser(options);\n    return parser.parse(tokens);\n  }\n\n  /**\n   * Parse Loop\n   */\n  parse(tokens) {\n    this.inline = new InlineLexer(tokens.links, this.options); // use an InlineLexer with a TextRenderer to extract pure text\n\n    this.inlineText = new InlineLexer(tokens.links, merge({}, this.options, {\n      renderer: new TextRenderer()\n    }));\n    this.tokens = tokens.reverse();\n    let out = '';\n\n    while (this.next()) {\n      out += this.tok();\n    }\n\n    return out;\n  }\n\n  /**\n   * Next Token\n   */\n  next() {\n    this.token = this.tokens.pop();\n    return this.token;\n  }\n\n  /**\n   * Preview Next Token\n   */\n  peek() {\n    return this.tokens[this.tokens.length - 1] || 0;\n  }\n\n  /**\n   * Parse Text Tokens\n   */\n  parseText() {\n    let body = this.token.text;\n\n    while (this.peek().type === 'text') {\n      body += '\\n' + this.next().text;\n    }\n\n    return this.inline.output(body);\n  }\n\n  /**\n   * Parse Current Token\n   */\n  tok() {\n    let body = '';\n\n    switch (this.token.type) {\n      case 'space':\n        {\n          return '';\n        }\n\n      case 'hr':\n        {\n          return this.renderer.hr();\n        }\n\n      case 'heading':\n        {\n          return this.renderer.heading(this.inline.output(this.token.text), this.token.depth, unescape(this.inlineText.output(this.token.text)), this.slugger);\n        }\n\n      case 'code':\n        {\n          return this.renderer.code(this.token.text, this.token.lang, this.token.escaped);\n        }\n\n      case 'table':\n        {\n          let header = '',\n              i,\n              row,\n              cell,\n              j; // header\n\n          cell = '';\n\n          for (i = 0; i < this.token.header.length; i++) {\n            cell += this.renderer.tablecell(this.inline.output(this.token.header[i]), {\n              header: true,\n              align: this.token.align[i]\n            });\n          }\n\n          header += this.renderer.tablerow(cell);\n\n          for (i = 0; i < this.token.cells.length; i++) {\n            row = this.token.cells[i];\n            cell = '';\n\n            for (j = 0; j < row.length; j++) {\n              cell += this.renderer.tablecell(this.inline.output(row[j]), {\n                header: false,\n                align: this.token.align[j]\n              });\n            }\n\n            body += this.renderer.tablerow(cell);\n          }\n\n          return this.renderer.table(header, body);\n        }\n\n      case 'blockquote_start':\n        {\n          body = '';\n\n          while (this.next().type !== 'blockquote_end') {\n            body += this.tok();\n          }\n\n          return this.renderer.blockquote(body);\n        }\n\n      case 'list_start':\n        {\n          body = '';\n          const ordered = this.token.ordered,\n                start = this.token.start;\n\n          while (this.next().type !== 'list_end') {\n            body += this.tok();\n          }\n\n          return this.renderer.list(body, ordered, start);\n        }\n\n      case 'list_item_start':\n        {\n          body = '';\n          const loose = this.token.loose;\n          const checked = this.token.checked;\n          const task = this.token.task;\n\n          if (this.token.task) {\n            if (loose) {\n              if (this.peek().type === 'text') {\n                const nextToken = this.peek();\n                nextToken.text = this.renderer.checkbox(checked) + ' ' + nextToken.text;\n              } else {\n                this.tokens.push({\n                  type: 'text',\n                  text: this.renderer.checkbox(checked)\n                });\n              }\n            } else {\n              body += this.renderer.checkbox(checked);\n            }\n          }\n\n          while (this.next().type !== 'list_item_end') {\n            body += !loose && this.token.type === 'text' ? this.parseText() : this.tok();\n          }\n\n          return this.renderer.listitem(body, task, checked);\n        }\n\n      case 'html':\n        {\n          // TODO parse inline content if parameter markdown=1\n          return this.renderer.html(this.token.text);\n        }\n\n      case 'paragraph':\n        {\n          return this.renderer.paragraph(this.inline.output(this.token.text));\n        }\n\n      case 'text':\n        {\n          return this.renderer.paragraph(this.parseText());\n        }\n\n      default:\n        {\n          const errMsg = 'Token with \"' + this.token.type + '\" type was not found.';\n\n          if (this.options.silent) {\n            console.log(errMsg);\n          } else {\n            throw new Error(errMsg);\n          }\n        }\n    }\n  }\n\n};","map":{"version":3,"sources":["/Users/aziz/Documents/Aziz-Final-project-react-new-markdown-previewer-hooks/node_modules/marked/src/Parser.js"],"names":["Renderer","require","Slugger","InlineLexer","TextRenderer","defaults","merge","unescape","module","exports","Parser","constructor","options","tokens","token","renderer","slugger","parse","parser","inline","links","inlineText","reverse","out","next","tok","pop","peek","length","parseText","body","text","type","output","hr","heading","depth","code","lang","escaped","header","i","row","cell","j","tablecell","align","tablerow","cells","table","blockquote","ordered","start","list","loose","checked","task","nextToken","checkbox","push","listitem","html","paragraph","errMsg","silent","console","log","Error"],"mappings":"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","sourcesContent":["const Renderer = require('./Renderer.js');\nconst Slugger = require('./Slugger.js');\nconst InlineLexer = require('./InlineLexer.js');\nconst TextRenderer = require('./TextRenderer.js');\nconst { defaults } = require('./defaults.js');\nconst {\n  merge,\n  unescape\n} = require('./helpers.js');\n\n/**\n * Parsing & Compiling\n */\nmodule.exports = class Parser {\n  constructor(options) {\n    this.tokens = [];\n    this.token = null;\n    this.options = options || defaults;\n    this.options.renderer = this.options.renderer || new Renderer();\n    this.renderer = this.options.renderer;\n    this.renderer.options = this.options;\n    this.slugger = new Slugger();\n  }\n\n  /**\n   * Static Parse Method\n   */\n  static parse(tokens, options) {\n    const parser = new Parser(options);\n    return parser.parse(tokens);\n  };\n\n  /**\n   * Parse Loop\n   */\n  parse(tokens) {\n    this.inline = new InlineLexer(tokens.links, this.options);\n    // use an InlineLexer with a TextRenderer to extract pure text\n    this.inlineText = new InlineLexer(\n      tokens.links,\n      merge({}, this.options, { renderer: new TextRenderer() })\n    );\n    this.tokens = tokens.reverse();\n\n    let out = '';\n    while (this.next()) {\n      out += this.tok();\n    }\n\n    return out;\n  };\n\n  /**\n   * Next Token\n   */\n  next() {\n    this.token = this.tokens.pop();\n    return this.token;\n  };\n\n  /**\n   * Preview Next Token\n   */\n  peek() {\n    return this.tokens[this.tokens.length - 1] || 0;\n  };\n\n  /**\n   * Parse Text Tokens\n   */\n  parseText() {\n    let body = this.token.text;\n\n    while (this.peek().type === 'text') {\n      body += '\\n' + this.next().text;\n    }\n\n    return this.inline.output(body);\n  };\n\n  /**\n   * Parse Current Token\n   */\n  tok() {\n    let body = '';\n    switch (this.token.type) {\n      case 'space': {\n        return '';\n      }\n      case 'hr': {\n        return this.renderer.hr();\n      }\n      case 'heading': {\n        return this.renderer.heading(\n          this.inline.output(this.token.text),\n          this.token.depth,\n          unescape(this.inlineText.output(this.token.text)),\n          this.slugger);\n      }\n      case 'code': {\n        return this.renderer.code(this.token.text,\n          this.token.lang,\n          this.token.escaped);\n      }\n      case 'table': {\n        let header = '',\n          i,\n          row,\n          cell,\n          j;\n\n        // header\n        cell = '';\n        for (i = 0; i < this.token.header.length; i++) {\n          cell += this.renderer.tablecell(\n            this.inline.output(this.token.header[i]),\n            { header: true, align: this.token.align[i] }\n          );\n        }\n        header += this.renderer.tablerow(cell);\n\n        for (i = 0; i < this.token.cells.length; i++) {\n          row = this.token.cells[i];\n\n          cell = '';\n          for (j = 0; j < row.length; j++) {\n            cell += this.renderer.tablecell(\n              this.inline.output(row[j]),\n              { header: false, align: this.token.align[j] }\n            );\n          }\n\n          body += this.renderer.tablerow(cell);\n        }\n        return this.renderer.table(header, body);\n      }\n      case 'blockquote_start': {\n        body = '';\n\n        while (this.next().type !== 'blockquote_end') {\n          body += this.tok();\n        }\n\n        return this.renderer.blockquote(body);\n      }\n      case 'list_start': {\n        body = '';\n        const ordered = this.token.ordered,\n          start = this.token.start;\n\n        while (this.next().type !== 'list_end') {\n          body += this.tok();\n        }\n\n        return this.renderer.list(body, ordered, start);\n      }\n      case 'list_item_start': {\n        body = '';\n        const loose = this.token.loose;\n        const checked = this.token.checked;\n        const task = this.token.task;\n\n        if (this.token.task) {\n          if (loose) {\n            if (this.peek().type === 'text') {\n              const nextToken = this.peek();\n              nextToken.text = this.renderer.checkbox(checked) + ' ' + nextToken.text;\n            } else {\n              this.tokens.push({\n                type: 'text',\n                text: this.renderer.checkbox(checked)\n              });\n            }\n          } else {\n            body += this.renderer.checkbox(checked);\n          }\n        }\n\n        while (this.next().type !== 'list_item_end') {\n          body += !loose && this.token.type === 'text'\n            ? this.parseText()\n            : this.tok();\n        }\n        return this.renderer.listitem(body, task, checked);\n      }\n      case 'html': {\n        // TODO parse inline content if parameter markdown=1\n        return this.renderer.html(this.token.text);\n      }\n      case 'paragraph': {\n        return this.renderer.paragraph(this.inline.output(this.token.text));\n      }\n      case 'text': {\n        return this.renderer.paragraph(this.parseText());\n      }\n      default: {\n        const errMsg = 'Token with \"' + this.token.type + '\" type was not found.';\n        if (this.options.silent) {\n          console.log(errMsg);\n        } else {\n          throw new Error(errMsg);\n        }\n      }\n    }\n  };\n};\n"]},"metadata":{},"sourceType":"script"}